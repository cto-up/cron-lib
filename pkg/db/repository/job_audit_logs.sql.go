// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: job_audit_logs.sql

package repository

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createJobAuditLog = `-- name: CreateJobAuditLog :one
INSERT INTO cron_job_audit_logs (
  user_id, tenant_id, "app_id", "request_id", "job_name", "scheduled_time", "start_time", "end_time", "status", "output", "error"
) VALUES (
  $1, $11::text, 
  $2, 
  $3, 
  $4, 
  $5, 
  $6, 
  $7, 
  $8, 
  $9, 
  $10
)
RETURNING id, app_id, request_id, job_name, scheduled_time, start_time, end_time, status, output, error, user_id, tenant_id, created_at, updated_at
`

type CreateJobAuditLogParams struct {
	UserID        string           `json:"user_id"`
	AppID         string           `json:"app_id"`
	RequestID     string           `json:"request_id"`
	JobName       string           `json:"job_name"`
	ScheduledTime pgtype.Timestamp `json:"scheduled_time"`
	StartTime     pgtype.Timestamp `json:"start_time"`
	EndTime       pgtype.Timestamp `json:"end_time"`
	Status        string           `json:"status"`
	Output        pgtype.Text      `json:"output"`
	Error         pgtype.Text      `json:"error"`
	TenantID      string           `json:"tenant_id"`
}

func (q *Queries) CreateJobAuditLog(ctx context.Context, arg CreateJobAuditLogParams) (CronJobAuditLog, error) {
	row := q.db.QueryRow(ctx, createJobAuditLog,
		arg.UserID,
		arg.AppID,
		arg.RequestID,
		arg.JobName,
		arg.ScheduledTime,
		arg.StartTime,
		arg.EndTime,
		arg.Status,
		arg.Output,
		arg.Error,
		arg.TenantID,
	)
	var i CronJobAuditLog
	err := row.Scan(
		&i.ID,
		&i.AppID,
		&i.RequestID,
		&i.JobName,
		&i.ScheduledTime,
		&i.StartTime,
		&i.EndTime,
		&i.Status,
		&i.Output,
		&i.Error,
		&i.UserID,
		&i.TenantID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteJobAuditLog = `-- name: DeleteJobAuditLog :one
DELETE FROM cron_job_audit_logs
WHERE id = $1 and tenant_id = $2::text
RETURNING id
`

type DeleteJobAuditLogParams struct {
	ID       uuid.UUID `json:"id"`
	TenantID string    `json:"tenant_id"`
}

func (q *Queries) DeleteJobAuditLog(ctx context.Context, arg DeleteJobAuditLogParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, deleteJobAuditLog, arg.ID, arg.TenantID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getJobAuditLogByID = `-- name: GetJobAuditLogByID :one
SELECT id, app_id, request_id, job_name, scheduled_time, start_time, end_time, status, output, error, user_id, tenant_id, created_at, updated_at FROM cron_job_audit_logs
WHERE id = $1 AND tenant_id = $2::text LIMIT 1
`

type GetJobAuditLogByIDParams struct {
	ID       uuid.UUID `json:"id"`
	TenantID string    `json:"tenant_id"`
}

func (q *Queries) GetJobAuditLogByID(ctx context.Context, arg GetJobAuditLogByIDParams) (CronJobAuditLog, error) {
	row := q.db.QueryRow(ctx, getJobAuditLogByID, arg.ID, arg.TenantID)
	var i CronJobAuditLog
	err := row.Scan(
		&i.ID,
		&i.AppID,
		&i.RequestID,
		&i.JobName,
		&i.ScheduledTime,
		&i.StartTime,
		&i.EndTime,
		&i.Status,
		&i.Output,
		&i.Error,
		&i.UserID,
		&i.TenantID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listJobAuditLogs = `-- name: ListJobAuditLogs :many
SELECT id, app_id, request_id, job_name, scheduled_time, start_time, end_time, status, output, error, user_id, tenant_id, created_at, updated_at FROM cron_job_audit_logs
WHERE tenant_id = $3::text
  AND (UPPER(job_name) LIKE UPPER($4) OR $4 IS NULL)
ORDER BY
  CASE WHEN $5::TEXT = 'app_id' AND $6::TEXT = 'asc' THEN app_id END ASC,
  CASE WHEN $5::TEXT = 'app_id' AND $6::TEXT != 'asc' THEN app_id END DESC
  ,
  CASE WHEN $5::TEXT = 'request_id' AND $6::TEXT = 'asc' THEN request_id END ASC,
  CASE WHEN $5::TEXT = 'request_id' AND $6::TEXT != 'asc' THEN request_id END DESC
  ,
  CASE WHEN $5::TEXT = 'job_name' AND $6::TEXT = 'asc' THEN job_name END ASC,
  CASE WHEN $5::TEXT = 'job_name' AND $6::TEXT != 'asc' THEN job_name END DESC
  ,
  CASE WHEN $5::TEXT = 'scheduled_time' AND $6::TEXT = 'asc' THEN scheduled_time END ASC,
  CASE WHEN $5::TEXT = 'scheduled_time' AND $6::TEXT != 'asc' THEN scheduled_time END DESC
  ,
  CASE WHEN $5::TEXT = 'start_time' AND $6::TEXT = 'asc' THEN start_time END ASC,
  CASE WHEN $5::TEXT = 'start_time' AND $6::TEXT != 'asc' THEN start_time END DESC
  ,
  CASE WHEN $5::TEXT = 'end_time' AND $6::TEXT = 'asc' THEN end_time END ASC,
  CASE WHEN $5::TEXT = 'end_time' AND $6::TEXT != 'asc' THEN end_time END DESC
  ,
  CASE WHEN $5::TEXT = 'status' AND $6::TEXT = 'asc' THEN status END ASC,
  CASE WHEN $5::TEXT = 'status' AND $6::TEXT != 'asc' THEN status END DESC
  ,
  CASE WHEN $5::TEXT = 'output' AND $6::TEXT = 'asc' THEN output END ASC,
  CASE WHEN $5::TEXT = 'output' AND $6::TEXT != 'asc' THEN output END DESC
  ,
  CASE WHEN $5::TEXT = 'error' AND $6::TEXT = 'asc' THEN error END ASC,
  CASE WHEN $5::TEXT = 'error' AND $6::TEXT != 'asc' THEN error END DESC
  
LIMIT $1
OFFSET $2
`

type ListJobAuditLogsParams struct {
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
	TenantID string      `json:"tenant_id"`
	Like     interface{} `json:"like"`
	SortBy   string      `json:"sortBy"`
	Order    string      `json:"order"`
}

func (q *Queries) ListJobAuditLogs(ctx context.Context, arg ListJobAuditLogsParams) ([]CronJobAuditLog, error) {
	rows, err := q.db.Query(ctx, listJobAuditLogs,
		arg.Limit,
		arg.Offset,
		arg.TenantID,
		arg.Like,
		arg.SortBy,
		arg.Order,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CronJobAuditLog{}
	for rows.Next() {
		var i CronJobAuditLog
		if err := rows.Scan(
			&i.ID,
			&i.AppID,
			&i.RequestID,
			&i.JobName,
			&i.ScheduledTime,
			&i.StartTime,
			&i.EndTime,
			&i.Status,
			&i.Output,
			&i.Error,
			&i.UserID,
			&i.TenantID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateJobAuditLog = `-- name: UpdateJobAuditLog :one
UPDATE cron_job_audit_logs 
SET 
    "end_time" =  COALESCE($2, end_time),
    "status" =  $3,
    "output" =  COALESCE($4, output),
    "error" =  COALESCE($5, error)

WHERE id = $1 AND tenant_id = $6::text
RETURNING id, app_id, request_id, job_name, scheduled_time, start_time, end_time, status, output, error, user_id, tenant_id, created_at, updated_at
`

type UpdateJobAuditLogParams struct {
	ID       uuid.UUID        `json:"id"`
	EndTime  pgtype.Timestamp `json:"end_time"`
	Status   string           `json:"status"`
	Output   pgtype.Text      `json:"output"`
	Error    pgtype.Text      `json:"error"`
	TenantID string           `json:"tenant_id"`
}

func (q *Queries) UpdateJobAuditLog(ctx context.Context, arg UpdateJobAuditLogParams) (CronJobAuditLog, error) {
	row := q.db.QueryRow(ctx, updateJobAuditLog,
		arg.ID,
		arg.EndTime,
		arg.Status,
		arg.Output,
		arg.Error,
		arg.TenantID,
	)
	var i CronJobAuditLog
	err := row.Scan(
		&i.ID,
		&i.AppID,
		&i.RequestID,
		&i.JobName,
		&i.ScheduledTime,
		&i.StartTime,
		&i.EndTime,
		&i.Status,
		&i.Output,
		&i.Error,
		&i.UserID,
		&i.TenantID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
