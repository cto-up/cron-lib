// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: registered_jobs.sql

package repository

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgconn"
)

const cleanupStaleRegisteredJobs = `-- name: CleanupStaleRegisteredJobs :execresult
DELETE FROM cron_registered_jobs
WHERE last_registered_at < NOW() - INTERVAL '24 hours'
  AND tenant_id = $1::text
`

func (q *Queries) CleanupStaleRegisteredJobs(ctx context.Context, tenantID string) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, cleanupStaleRegisteredJobs, tenantID)
}

const countJobAuditLogsByJobName = `-- name: CountJobAuditLogsByJobName :one
SELECT COUNT(*) 
FROM cron_job_audit_logs
WHERE job_name = $1::text
  AND tenant_id = $2::text
`

type CountJobAuditLogsByJobNameParams struct {
	JobName  string `json:"job_name"`
	TenantID string `json:"tenant_id"`
}

func (q *Queries) CountJobAuditLogsByJobName(ctx context.Context, arg CountJobAuditLogsByJobNameParams) (int64, error) {
	row := q.db.QueryRow(ctx, countJobAuditLogsByJobName, arg.JobName, arg.TenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRegisteredJobs = `-- name: CountRegisteredJobs :one
SELECT COUNT(*) 
FROM cron_registered_jobs
WHERE tenant_id = $1::text
  AND (UPPER(job_name) LIKE UPPER($2) OR $2 IS NULL)
`

type CountRegisteredJobsParams struct {
	TenantID   string      `json:"tenant_id"`
	SearchTerm interface{} `json:"search_term"`
}

func (q *Queries) CountRegisteredJobs(ctx context.Context, arg CountRegisteredJobsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countRegisteredJobs, arg.TenantID, arg.SearchTerm)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteRegisteredJob = `-- name: DeleteRegisteredJob :exec
DELETE FROM cron_registered_jobs
WHERE job_name = $1::text
  AND tenant_id = $2::text
`

type DeleteRegisteredJobParams struct {
	JobName  string `json:"job_name"`
	TenantID string `json:"tenant_id"`
}

func (q *Queries) DeleteRegisteredJob(ctx context.Context, arg DeleteRegisteredJobParams) error {
	_, err := q.db.Exec(ctx, deleteRegisteredJob, arg.JobName, arg.TenantID)
	return err
}

const getRegisteredJobByID = `-- name: GetRegisteredJobByID :one
SELECT id, job_name, schedule, is_long_running, is_enabled, last_registered_at, instance_id, tenant_id, created_at, updated_at 
FROM cron_registered_jobs
WHERE id = $1::uuid
  AND tenant_id = $2::text
`

type GetRegisteredJobByIDParams struct {
	ID       uuid.UUID `json:"id"`
	TenantID string    `json:"tenant_id"`
}

func (q *Queries) GetRegisteredJobByID(ctx context.Context, arg GetRegisteredJobByIDParams) (CronRegisteredJob, error) {
	row := q.db.QueryRow(ctx, getRegisteredJobByID, arg.ID, arg.TenantID)
	var i CronRegisteredJob
	err := row.Scan(
		&i.ID,
		&i.JobName,
		&i.Schedule,
		&i.IsLongRunning,
		&i.IsEnabled,
		&i.LastRegisteredAt,
		&i.InstanceID,
		&i.TenantID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listJobAuditLogsByJobName = `-- name: ListJobAuditLogsByJobName :many
SELECT id, app_id, request_id, job_name, scheduled_time, start_time, end_time, status, output, error, user_id, tenant_id, created_at, updated_at 
FROM cron_job_audit_logs
WHERE job_name = $1::text
  AND tenant_id = $2::text
ORDER BY
  CASE WHEN $3::TEXT = 'scheduled_time' AND $4::TEXT = 'asc' THEN scheduled_time END ASC,
  CASE WHEN $3::TEXT = 'scheduled_time' AND $4::TEXT != 'asc' THEN scheduled_time END DESC,
  CASE WHEN $3::TEXT = 'start_time' AND $4::TEXT = 'asc' THEN start_time END ASC,
  CASE WHEN $3::TEXT = 'start_time' AND $4::TEXT != 'asc' THEN start_time END DESC,
  CASE WHEN $3::TEXT = 'end_time' AND $4::TEXT = 'asc' THEN end_time END ASC,
  CASE WHEN $3::TEXT = 'end_time' AND $4::TEXT != 'asc' THEN end_time END DESC,
  CASE WHEN $3::TEXT = 'status' AND $4::TEXT = 'asc' THEN status END ASC,
  CASE WHEN $3::TEXT = 'status' AND $4::TEXT != 'asc' THEN status END DESC
LIMIT $6::int
OFFSET $5::int
`

type ListJobAuditLogsByJobNameParams struct {
	JobName  string `json:"job_name"`
	TenantID string `json:"tenant_id"`
	SortBy   string `json:"sort_by"`
	Order    string `json:"order"`
	Offset   int32  `json:"offset"`
	Limit    int32  `json:"limit"`
}

func (q *Queries) ListJobAuditLogsByJobName(ctx context.Context, arg ListJobAuditLogsByJobNameParams) ([]CronJobAuditLog, error) {
	rows, err := q.db.Query(ctx, listJobAuditLogsByJobName,
		arg.JobName,
		arg.TenantID,
		arg.SortBy,
		arg.Order,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CronJobAuditLog{}
	for rows.Next() {
		var i CronJobAuditLog
		if err := rows.Scan(
			&i.ID,
			&i.AppID,
			&i.RequestID,
			&i.JobName,
			&i.ScheduledTime,
			&i.StartTime,
			&i.EndTime,
			&i.Status,
			&i.Output,
			&i.Error,
			&i.UserID,
			&i.TenantID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRegisteredJobs = `-- name: ListRegisteredJobs :many
SELECT rj.id, rj.job_name, rj.schedule, rj.is_long_running, rj.is_enabled, rj.last_registered_at, rj.instance_id, rj.tenant_id, rj.created_at, rj.updated_at, 
  (SELECT COUNT(*) FROM cron_job_audit_logs al 
   WHERE al.job_name = rj.job_name AND al.tenant_id = rj.tenant_id) as execution_count
FROM cron_registered_jobs rj
WHERE rj.tenant_id = $1::text
  AND (UPPER(rj.job_name) LIKE UPPER($2) OR $2 IS NULL)
ORDER BY
  CASE WHEN $3::TEXT = 'job_name' AND $4::TEXT = 'asc' THEN rj.job_name END ASC,
  CASE WHEN $3::TEXT = 'job_name' AND $4::TEXT != 'asc' THEN rj.job_name END DESC,
  CASE WHEN $3::TEXT = 'schedule' AND $4::TEXT = 'asc' THEN rj.schedule END ASC,
  CASE WHEN $3::TEXT = 'schedule' AND $4::TEXT != 'asc' THEN rj.schedule END DESC,
  CASE WHEN $3::TEXT = 'last_registered_at' AND $4::TEXT = 'asc' THEN rj.last_registered_at END ASC,
  CASE WHEN $3::TEXT = 'last_registered_at' AND $4::TEXT != 'asc' THEN rj.last_registered_at END DESC,
  CASE WHEN $3::TEXT = 'is_enabled' AND $4::TEXT = 'asc' THEN rj.is_enabled END ASC,
  CASE WHEN $3::TEXT = 'is_enabled' AND $4::TEXT != 'asc' THEN rj.is_enabled END DESC
LIMIT $6::int
OFFSET $5::int
`

type ListRegisteredJobsParams struct {
	TenantID   string      `json:"tenant_id"`
	SearchTerm interface{} `json:"search_term"`
	SortBy     string      `json:"sort_by"`
	Order      string      `json:"order"`
	Offset     int32       `json:"offset"`
	Limit      int32       `json:"limit"`
}

type ListRegisteredJobsRow struct {
	ID               uuid.UUID `json:"id"`
	JobName          string    `json:"job_name"`
	Schedule         string    `json:"schedule"`
	IsLongRunning    bool      `json:"is_long_running"`
	IsEnabled        bool      `json:"is_enabled"`
	LastRegisteredAt time.Time `json:"last_registered_at"`
	InstanceID       string    `json:"instance_id"`
	TenantID         string    `json:"tenant_id"`
	CreatedAt        time.Time `json:"created_at"`
	UpdatedAt        time.Time `json:"updated_at"`
	ExecutionCount   int64     `json:"execution_count"`
}

func (q *Queries) ListRegisteredJobs(ctx context.Context, arg ListRegisteredJobsParams) ([]ListRegisteredJobsRow, error) {
	rows, err := q.db.Query(ctx, listRegisteredJobs,
		arg.TenantID,
		arg.SearchTerm,
		arg.SortBy,
		arg.Order,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRegisteredJobsRow{}
	for rows.Next() {
		var i ListRegisteredJobsRow
		if err := rows.Scan(
			&i.ID,
			&i.JobName,
			&i.Schedule,
			&i.IsLongRunning,
			&i.IsEnabled,
			&i.LastRegisteredAt,
			&i.InstanceID,
			&i.TenantID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ExecutionCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRegisteredJobEnabled = `-- name: UpdateRegisteredJobEnabled :execresult
UPDATE cron_registered_jobs
SET is_enabled = $1::boolean,
    updated_at = NOW()
WHERE id = $2::uuid
  AND tenant_id = $3::text
`

type UpdateRegisteredJobEnabledParams struct {
	IsEnabled bool      `json:"is_enabled"`
	ID        uuid.UUID `json:"id"`
	TenantID  string    `json:"tenant_id"`
}

func (q *Queries) UpdateRegisteredJobEnabled(ctx context.Context, arg UpdateRegisteredJobEnabledParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, updateRegisteredJobEnabled, arg.IsEnabled, arg.ID, arg.TenantID)
}

const upsertRegisteredJob = `-- name: UpsertRegisteredJob :one
INSERT INTO cron_registered_jobs (
  job_name, schedule, is_long_running, is_enabled, 
  last_registered_at, instance_id, tenant_id
) VALUES (
  $1::text,
  $2::text,
  $3::boolean,
  $4::boolean,
  NOW(),
  $5::text,
  $6::text
)
ON CONFLICT (tenant_id, job_name) DO UPDATE
SET 
  schedule = EXCLUDED.schedule,
  is_long_running = EXCLUDED.is_long_running,
  is_enabled = EXCLUDED.is_enabled,
  last_registered_at = NOW(),
  instance_id = EXCLUDED.instance_id,
  updated_at = NOW()
RETURNING id, job_name, schedule, is_long_running, is_enabled, last_registered_at, instance_id, tenant_id, created_at, updated_at
`

type UpsertRegisteredJobParams struct {
	JobName       string `json:"job_name"`
	Schedule      string `json:"schedule"`
	IsLongRunning bool   `json:"is_long_running"`
	IsEnabled     bool   `json:"is_enabled"`
	InstanceID    string `json:"instance_id"`
	TenantID      string `json:"tenant_id"`
}

func (q *Queries) UpsertRegisteredJob(ctx context.Context, arg UpsertRegisteredJobParams) (CronRegisteredJob, error) {
	row := q.db.QueryRow(ctx, upsertRegisteredJob,
		arg.JobName,
		arg.Schedule,
		arg.IsLongRunning,
		arg.IsEnabled,
		arg.InstanceID,
		arg.TenantID,
	)
	var i CronRegisteredJob
	err := row.Scan(
		&i.ID,
		&i.JobName,
		&i.Schedule,
		&i.IsLongRunning,
		&i.IsEnabled,
		&i.LastRegisteredAt,
		&i.InstanceID,
		&i.TenantID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
