// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: jobs.sql

package repository

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const acquireJobLockInDB = `-- name: AcquireJobLockInDB :one
INSERT INTO cron_jobs (
  tenant_id, "lock", "job_name", "status", "last_execution_time", "next_execution_time", 
  "locked_by", "locked_at"
) VALUES (
  $1::text,
  $2::text,
  $3::text,
  'running',
  $4::timestamptz,
  $5::timestamptz,
  $6::text,
  $4::timestamptz
)
ON CONFLICT (tenant_id, lock) DO UPDATE
SET 
  status = 'running',
  last_execution_time = $4::timestamptz,
  next_execution_time = $5::timestamptz,
  locked_by = $6::text,
  locked_at = $4::timestamptz,
  updated_at = $4::timestamptz
WHERE cron_jobs.locked_at IS NULL 
   OR cron_jobs.locked_at < $4::timestamptz - INTERVAL '10 minutes'
   OR cron_jobs.status != 'running'
RETURNING id
`

type AcquireJobLockInDBParams struct {
	TenantID    string    `json:"tenant_id"`
	Lock        string    `json:"lock"`
	JobName     string    `json:"job_name"`
	Now         time.Time `json:"now"`
	NextRunTime time.Time `json:"next_run_time"`
	InstanceID  string    `json:"instance_id"`
}

func (q *Queries) AcquireJobLockInDB(ctx context.Context, arg AcquireJobLockInDBParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, acquireJobLockInDB,
		arg.TenantID,
		arg.Lock,
		arg.JobName,
		arg.Now,
		arg.NextRunTime,
		arg.InstanceID,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const cleanupOldTasks = `-- name: CleanupOldTasks :execresult
DELETE FROM cron_jobs
WHERE status IN ('completed', 'failed') 
  AND updated_at < NOW() - INTERVAL '7 days'
  AND tenant_id = $1::text
`

func (q *Queries) CleanupOldTasks(ctx context.Context, tenantID string) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, cleanupOldTasks, tenantID)
}

const cleanupStaleLocks = `-- name: CleanupStaleLocks :execresult
UPDATE cron_jobs 
SET status = 'failed',
    locked_by = NULL,
    locked_at = NULL,
    updated_at = NOW()
WHERE status = 'running' 
  AND locked_at < NOW() - INTERVAL '15 minutes'
  AND tenant_id = $1::text
`

// NEW: Clean up stale locks from crashed instances
func (q *Queries) CleanupStaleLocks(ctx context.Context, tenantID string) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, cleanupStaleLocks, tenantID)
}

const createJob = `-- name: CreateJob :one
INSERT INTO cron_jobs (
  "lock", "job_name", tenant_id, "status", "last_execution_time", "next_execution_time", "locked_by", "locked_at"
) VALUES (
  $1, $2, $7::text, $2, $3, $4, $5, $6
)
RETURNING id, lock, job_name, status, last_execution_time, next_execution_time, locked_by, locked_at, tenant_id, created_at, updated_at
`

type CreateJobParams struct {
	Lock              string             `json:"lock"`
	JobName           string             `json:"job_name"`
	LastExecutionTime pgtype.Timestamptz `json:"last_execution_time"`
	NextExecutionTime pgtype.Timestamptz `json:"next_execution_time"`
	LockedBy          pgtype.Text        `json:"locked_by"`
	LockedAt          pgtype.Timestamptz `json:"locked_at"`
	TenantID          string             `json:"tenant_id"`
}

func (q *Queries) CreateJob(ctx context.Context, arg CreateJobParams) (CronJob, error) {
	row := q.db.QueryRow(ctx, createJob,
		arg.Lock,
		arg.JobName,
		arg.LastExecutionTime,
		arg.NextExecutionTime,
		arg.LockedBy,
		arg.LockedAt,
		arg.TenantID,
	)
	var i CronJob
	err := row.Scan(
		&i.ID,
		&i.Lock,
		&i.JobName,
		&i.Status,
		&i.LastExecutionTime,
		&i.NextExecutionTime,
		&i.LockedBy,
		&i.LockedAt,
		&i.TenantID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteJob = `-- name: DeleteJob :one
DELETE FROM cron_jobs
WHERE id = $1 and tenant_id = $2::text
RETURNING id
`

type DeleteJobParams struct {
	ID       uuid.UUID `json:"id"`
	TenantID string    `json:"tenant_id"`
}

func (q *Queries) DeleteJob(ctx context.Context, arg DeleteJobParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, deleteJob, arg.ID, arg.TenantID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const forceUnlockJob = `-- name: ForceUnlockJob :exec
UPDATE cron_jobs
SET status = 'failed',
    locked_by = NULL,
    locked_at = NULL,
    updated_at = NOW()
WHERE id = $1::uuid
  AND tenant_id = $2::text
`

type ForceUnlockJobParams struct {
	JobID    uuid.UUID `json:"job_id"`
	TenantID string    `json:"tenant_id"`
}

// NEW: Force unlock a specific job (for admin operations)
func (q *Queries) ForceUnlockJob(ctx context.Context, arg ForceUnlockJobParams) error {
	_, err := q.db.Exec(ctx, forceUnlockJob, arg.JobID, arg.TenantID)
	return err
}

const getJobByID = `-- name: GetJobByID :one
SELECT id, lock, job_name, status, last_execution_time, next_execution_time, locked_by, locked_at, tenant_id, created_at, updated_at FROM cron_jobs
WHERE id = $1 AND tenant_id = $2::text LIMIT 1
`

type GetJobByIDParams struct {
	ID       uuid.UUID `json:"id"`
	TenantID string    `json:"tenant_id"`
}

func (q *Queries) GetJobByID(ctx context.Context, arg GetJobByIDParams) (CronJob, error) {
	row := q.db.QueryRow(ctx, getJobByID, arg.ID, arg.TenantID)
	var i CronJob
	err := row.Scan(
		&i.ID,
		&i.Lock,
		&i.JobName,
		&i.Status,
		&i.LastExecutionTime,
		&i.NextExecutionTime,
		&i.LockedBy,
		&i.LockedAt,
		&i.TenantID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getStaleJobs = `-- name: GetStaleJobs :many
SELECT id, "lock", job_name, tenant_id, locked_by, locked_at, status
FROM cron_jobs
WHERE status = 'running' 
  AND locked_at < NOW() - INTERVAL '15 minutes'
  AND tenant_id = $1::text
`

type GetStaleJobsRow struct {
	ID       uuid.UUID          `json:"id"`
	Lock     string             `json:"lock"`
	JobName  string             `json:"job_name"`
	TenantID string             `json:"tenant_id"`
	LockedBy pgtype.Text        `json:"locked_by"`
	LockedAt pgtype.Timestamptz `json:"locked_at"`
	Status   string             `json:"status"`
}

// NEW: Get jobs that are potentially stuck
func (q *Queries) GetStaleJobs(ctx context.Context, tenantID string) ([]GetStaleJobsRow, error) {
	rows, err := q.db.Query(ctx, getStaleJobs, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetStaleJobsRow{}
	for rows.Next() {
		var i GetStaleJobsRow
		if err := rows.Scan(
			&i.ID,
			&i.Lock,
			&i.JobName,
			&i.TenantID,
			&i.LockedBy,
			&i.LockedAt,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isJobLocked = `-- name: IsJobLocked :one
SELECT 
  id,
  CASE 
    WHEN status = 'running' AND locked_at > NOW() - INTERVAL '10 minutes' THEN true
    ELSE false
  END as is_locked,
  locked_by,
  locked_at
FROM cron_jobs
WHERE tenant_id = $1::text 
  AND lock = $2::text
LIMIT 1
`

type IsJobLockedParams struct {
	TenantID string `json:"tenant_id"`
	Lock     string `json:"lock"`
}

type IsJobLockedRow struct {
	ID       uuid.UUID          `json:"id"`
	IsLocked bool               `json:"is_locked"`
	LockedBy pgtype.Text        `json:"locked_by"`
	LockedAt pgtype.Timestamptz `json:"locked_at"`
}

// NEW: Check if a job is currently locked by any instance
func (q *Queries) IsJobLocked(ctx context.Context, arg IsJobLockedParams) (IsJobLockedRow, error) {
	row := q.db.QueryRow(ctx, isJobLocked, arg.TenantID, arg.Lock)
	var i IsJobLockedRow
	err := row.Scan(
		&i.ID,
		&i.IsLocked,
		&i.LockedBy,
		&i.LockedAt,
	)
	return i, err
}

const listJobs = `-- name: ListJobs :many
SELECT id, lock, job_name, status, last_execution_time, next_execution_time, locked_by, locked_at, tenant_id, created_at, updated_at FROM cron_jobs
WHERE tenant_id = $3::text
  AND (UPPER(job_name) LIKE UPPER($4) OR $4 IS NULL)
ORDER BY
  CASE WHEN $5::TEXT = 'lock' AND $6::TEXT = 'asc' THEN lock END ASC,
  CASE WHEN $5::TEXT = 'lock' AND $6::TEXT != 'asc' THEN lock END DESC,
  CASE WHEN $5::TEXT = 'job_name' AND $6::TEXT = 'asc' THEN job_name END ASC,
  CASE WHEN $5::TEXT = 'job_name' AND $6::TEXT != 'asc' THEN job_name END DESC,
  CASE WHEN $5::TEXT = 'status' AND $6::TEXT = 'asc' THEN status END ASC,
  CASE WHEN $5::TEXT = 'status' AND $6::TEXT != 'asc' THEN status END DESC,
  CASE WHEN $5::TEXT = 'last_execution_time' AND $6::TEXT = 'asc' THEN last_execution_time END ASC,
  CASE WHEN $5::TEXT = 'last_execution_time' AND $6::TEXT != 'asc' THEN last_execution_time END DESC,
  CASE WHEN $5::TEXT = 'next_execution_time' AND $6::TEXT = 'asc' THEN next_execution_time END ASC,
  CASE WHEN $5::TEXT = 'next_execution_time' AND $6::TEXT != 'asc' THEN next_execution_time END DESC,
  CASE WHEN $5::TEXT = 'locked_by' AND $6::TEXT = 'asc' THEN locked_by END ASC,
  CASE WHEN $5::TEXT = 'locked_by' AND $6::TEXT != 'asc' THEN locked_by END DESC,
  CASE WHEN $5::TEXT = 'locked_at' AND $6::TEXT = 'asc' THEN locked_at END ASC,
  CASE WHEN $5::TEXT = 'locked_at' AND $6::TEXT != 'asc' THEN locked_at END DESC
LIMIT $1
OFFSET $2
`

type ListJobsParams struct {
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
	TenantID string      `json:"tenant_id"`
	Like     interface{} `json:"like"`
	SortBy   string      `json:"sortBy"`
	Order    string      `json:"order"`
}

func (q *Queries) ListJobs(ctx context.Context, arg ListJobsParams) ([]CronJob, error) {
	rows, err := q.db.Query(ctx, listJobs,
		arg.Limit,
		arg.Offset,
		arg.TenantID,
		arg.Like,
		arg.SortBy,
		arg.Order,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CronJob{}
	for rows.Next() {
		var i CronJob
		if err := rows.Scan(
			&i.ID,
			&i.Lock,
			&i.JobName,
			&i.Status,
			&i.LastExecutionTime,
			&i.NextExecutionTime,
			&i.LockedBy,
			&i.LockedAt,
			&i.TenantID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const releaseAdvisoryLock = `-- name: ReleaseAdvisoryLock :exec
SELECT pg_advisory_unlock($1::bigint)
`

func (q *Queries) ReleaseAdvisoryLock(ctx context.Context, lockID int64) error {
	_, err := q.db.Exec(ctx, releaseAdvisoryLock, lockID)
	return err
}

const releaseTaskLock = `-- name: ReleaseTaskLock :exec
UPDATE cron_jobs
SET status = 'completed', 
    updated_at = NOW(),
    locked_by = NULL,
    locked_at = NULL
WHERE id = $1::uuid 
  AND tenant_id = $2::text
`

type ReleaseTaskLockParams struct {
	ID       uuid.UUID `json:"id"`
	TenantID string    `json:"tenant_id"`
}

func (q *Queries) ReleaseTaskLock(ctx context.Context, arg ReleaseTaskLockParams) error {
	_, err := q.db.Exec(ctx, releaseTaskLock, arg.ID, arg.TenantID)
	return err
}

const tryAdvisoryLock = `-- name: TryAdvisoryLock :one
SELECT pg_try_advisory_lock($1::bigint) as lock_acquired
`

func (q *Queries) TryAdvisoryLock(ctx context.Context, lockID int64) (bool, error) {
	row := q.db.QueryRow(ctx, tryAdvisoryLock, lockID)
	var lock_acquired bool
	err := row.Scan(&lock_acquired)
	return lock_acquired, err
}

const updateJob = `-- name: UpdateJob :one
UPDATE cron_jobs 
SET "lock" = $2,
    "job_name" = $3,
    "status" = $4,
    "last_execution_time" = COALESCE($5::timestamptz, last_execution_time),
    "next_execution_time" = COALESCE($6::timestamptz, next_execution_time),
    "locked_by" = COALESCE($7, locked_by),
    "locked_at" = COALESCE($8::timestamptz, locked_at),
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $9::text
RETURNING id, lock, job_name, status, last_execution_time, next_execution_time, locked_by, locked_at, tenant_id, created_at, updated_at
`

type UpdateJobParams struct {
	ID                uuid.UUID          `json:"id"`
	Lock              string             `json:"lock"`
	JobName           string             `json:"job_name"`
	Status            string             `json:"status"`
	LastExecutionTime pgtype.Timestamptz `json:"last_execution_time"`
	NextExecutionTime pgtype.Timestamptz `json:"next_execution_time"`
	LockedBy          pgtype.Text        `json:"locked_by"`
	LockedAt          pgtype.Timestamptz `json:"locked_at"`
	TenantID          string             `json:"tenant_id"`
}

func (q *Queries) UpdateJob(ctx context.Context, arg UpdateJobParams) (CronJob, error) {
	row := q.db.QueryRow(ctx, updateJob,
		arg.ID,
		arg.Lock,
		arg.JobName,
		arg.Status,
		arg.LastExecutionTime,
		arg.NextExecutionTime,
		arg.LockedBy,
		arg.LockedAt,
		arg.TenantID,
	)
	var i CronJob
	err := row.Scan(
		&i.ID,
		&i.Lock,
		&i.JobName,
		&i.Status,
		&i.LastExecutionTime,
		&i.NextExecutionTime,
		&i.LockedBy,
		&i.LockedAt,
		&i.TenantID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateJobHeartbeat = `-- name: UpdateJobHeartbeat :exec
UPDATE cron_jobs
SET locked_at = NOW(),
    updated_at = NOW()
WHERE id = $1::uuid
  AND locked_by = $2::text
  AND status = 'running'
`

type UpdateJobHeartbeatParams struct {
	JobID      uuid.UUID `json:"job_id"`
	InstanceID string    `json:"instance_id"`
}

// NEW: Heartbeat update for long-running jobs
func (q *Queries) UpdateJobHeartbeat(ctx context.Context, arg UpdateJobHeartbeatParams) error {
	_, err := q.db.Exec(ctx, updateJobHeartbeat, arg.JobID, arg.InstanceID)
	return err
}

const updateJobStatusToCompleted = `-- name: UpdateJobStatusToCompleted :exec
UPDATE cron_jobs 
SET status = 'completed', 
    updated_at = NOW(),
    locked_by = NULL,
    locked_at = NULL
WHERE id = $1::uuid
`

func (q *Queries) UpdateJobStatusToCompleted(ctx context.Context, jobID uuid.UUID) error {
	_, err := q.db.Exec(ctx, updateJobStatusToCompleted, jobID)
	return err
}

const updateJobStatusToFailed = `-- name: UpdateJobStatusToFailed :exec
UPDATE cron_jobs 
SET status = 'failed', 
    updated_at = NOW(),
    locked_by = NULL,
    locked_at = NULL
WHERE id = $1::uuid
`

func (q *Queries) UpdateJobStatusToFailed(ctx context.Context, jobID uuid.UUID) error {
	_, err := q.db.Exec(ctx, updateJobStatusToFailed, jobID)
	return err
}
